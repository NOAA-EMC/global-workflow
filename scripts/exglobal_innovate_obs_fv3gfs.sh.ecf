#!/bin/ksh
################################################################################
####  UNIX Script Documentation Block
#                      .                                             .
# Script name:         exglobal_innovate_obs_fv3gfs.sh.ecf
# Script description:  Compute global_gsi innovations
#
# Author: Rahul Mahajan     Org: NCEP/EMC     Date: 2017-03-02
#
# Abstract: This script computes global_gsi innovations
#
# $Id$
#
# Attributes:
#   Language: POSIX shell
#   Machine: WCOSS-Cray/Theia
#
################################################################################

# Set environment.
export VERBOSE=${VERBOSE:-"YES"}
if [ $VERBOSE = "YES" ]; then
   echo $(date) EXECUTING $0 $* >&2
   set -x
fi

# Directories.
pwd=$(pwd)
export NWPROD=${NWPROD:-$pwd}
export BASE_GSI=${BASE_GSI:-$NWPROD}
export DATA=${DATA:-$pwd/innovate_obs.$$}
export COMIN=${COMIN:-$pwd}
export COMIN_OBS=${COMIN_OBS:-$COMIN}
export COMIN_GES=${COMIN_GES:-$COMIN}
export COMOUT=${COMOUT:-$COMIN}

# Utilities
export NLN=${NLN:-"/bin/ln -sf"}
export ERRSCRIPT=${ERRSCRIPT:-'eval [[ $err = 0 ]]'}

# Scripts.
ANALYSISSH=${ANALYSISSH:-$BASE_GSI/scripts/exglobal_analysis_fv3gfs.sh.ecf}

# Prefix and Suffix Variables.
export APREFIX=${APREFIX:-""}
export ASUFFIX=${ASUFFIX:-""}

# Select obs
export RUN_SELECT=${RUN_SELECT:-"YES"}
export USE_SELECT=${USE_SELECT:-"NO"}
export SELECT_OBS=${SELECT_OBS:-$COMOUT/${APREFIX}obsinput}

# Observation Operator GSI namelist initialization
SETUP_INVOBS=${SETUP_INVOBS:-""}
GRIDOPTS_INVOBS=${GRIDOPTS_INVOBS:-""}
BKGVERR_INVOBS=${BKGVERR_INVOBS:-""}
ANBKGERR_INVOBS=${ANBKGERR_INVOBS:-""}
JCOPTS_INVOBS=${JCOPTS_INVOBS:-""}
STRONGOPTS_INVOBS=${STRONGOPTS_INVOBS:-""}
OBSQC_INVOBS=${OBSQC_INVOBS:-""}
OBSINPUT_INVOBS=${OBSINPUT_INVOBS:-""}
SUPERRAD_INVOBS=${SUPERRAD_INVOBS:-""}
SINGLEOB_INVOBS=${SINGLEOB_INVOBS:-""}
LAGDATA_INVOBS=${LAGDATA_INVOBS:-""}
HYBRID_ENSEMBLE_INVOBS=${HYBRID_ENSEMBLE_INVOBS:-""}
RAPIDREFRESH_CLDSURF_INVOBS=${RAPIDREFRESH_CLDSURF_INVOBS:-""}
CHEM_INVOBS=${CHEM_INVOBS:-""}

################################################################################
#  Preprocessing
[[ -d $DATA ]] && rm -rf $DATA
mkdir -p $DATA
cd $DATA || exit 8

################################################################################
# ObsInput file from ensemble mean
rm -f obs_input*
$NLN $SELECT_OBS obs_input.tar

# Whether to save or skip obs
if [ $RUN_SELECT = "YES" -a $USE_SELECT = "NO" ]; then
   lread_obs_save=".true."
   lread_obs_skip=".false."
elif [ $RUN_SELECT = "NO" -a $USE_SELECT = "YES" ]; then
   lread_obs_save=".false."
   lread_obs_skip=".true."
fi

################################################################################
# Innovation Specific setup for ANALYSISSH
export DIAG_SUFFIX=${DIAG_SUFFIX:-""}
export DIAG_COMPRESS=${DIAG_COMPRESS:-"NO"}
export DIAG_TARBALL=${DIAG_TARBALL:-"YES"}
export DOHYBVAR="NO"
export DO_CALC_INCREMENT="NO"

# GSI Namelist options for observation operator only
export SETUP="miter=0,niter=1,lread_obs_save=$lread_obs_save,lread_obs_skip=$lread_obs_skip,lwrite_predterms=.true.,lwrite_peakwt=.true.,reduce_diag=.true.,$SETUP_INVOBS"
export GRIDOPTS="$GRIDOPTS_INVOBS"
export BKGVERR="bkgv_flowdep=.false.,$BKGVERR_INVOBS"
export ANBKGERR="$ANBKGERR_INVOBS"
export JCOPTS="$JCOPTS_INVOBS"
export STRONGOPTS="tlnmc_option=0,nstrong=0,nvmodes_keep=0,baldiag_full=.false.,baldiag_inc=.false.,$STRONGOPTS_INVOBS"
export OBSQC="$OBSQC_INVOBS"
export OBSINPUT="$OBSINPUT_INVOBS"
export SUPERRAD="$SUPERRAD_INVOBS"
export SINGLEOB="$SINGLEOB_INVOBS"
export LAGDATA="$LAGDATA_INVOBS"
export HYBRID_ENSEMBLE=""
export RAPIDREFRESH_CLDSURF="$RAPIDREFRESH_CLDSURF_INVOBS"
export CHEM="$CHEM_INVOBS"

################################################################################
# Execute GSI as a forward operator

$ANALYSISSH

export ERR=$?
export err=$ERR
$ERRSCRIPT || exit 2

################################################################################
# Postprocessing
cd $pwd
[[ ${KEEPDATA:-"NO"} = "NO" ]]&& rm -rf $DATA
set +x
if [ $VERBOSE = "YES" ]; then
   echo $(date) EXITING $0 with return code $err >&2
fi
exit $err
