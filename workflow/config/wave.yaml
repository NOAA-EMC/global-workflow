config_wave:
  filename: config.wave
  content: !expand |
    #!/bin/ksh -x
    #
    # This file is automatically generated from the YAML-based system
    # in ecf/ecfutils/.  Any changes will be overwritten if
    # setup_case.sh is rerun.
    
    ########## config.base ##########
    # Common to all steps

      echo "BEGIN: config.wave"
      export wave_sys_ver=v1.0.0

      export COMPONENTRSTwave={doc.wave_settings.COMPONENTRSTwave}
      export HOMEwave={doc.places.HOMEgfs}
      export HOMEgefs={doc.places.HOMEgfs}
      
      # Grids for wave model
      export waveGRD='{doc.wave_settings.waveGRD}'
      export waveGRDN='{doc.wave_settings.waveGRDN}' # gridnumber for ww3_multi
      export waveGRDG='10 20 30' # gridgroup for ww3_multi
      
      # ESMF input grid
      export waveesmfGRD='' # input grid
      
      # Grids for output fields
      export waveuoutpGRD=points
      export waveinterpGRD='' # Grids that need to be interpolated from native
      # in POST will generate grib unless gribOK not set
      export wavesbsGRD=''  # side-by-side grids generated as wave model runs, writes to com
      export wavepostGRD='gwes_30m' # Native grids that will be post-processed (grib2)
      
      if [ "$CDUMP" = "gdas" ]
      then
        export FHMAX_WAV={doc.output_settings.FHMAX_WAV}
      else
        export FHMAX_WAV={doc.output_settings.FHMAX_WAV_GFS}
      fi
      export WAVHINDH={doc.wave_settings.WAVHINDH}
      export FHMIN_WAV={doc.output_settings.FHMIN_WAV}
      export FHOUT_WAV={doc.output_settings.FHOUT_WAV}
      export FHMAX_HF_WAV={doc.output_settings.FHMAX_HF_WAV}
      export FHOUT_HF_WAV={doc.output_settings.FHOUT_HF_WAV}
      
      # Output stride
      export WAV_WND_HOUR_INC=1      # This value should match with the one used in
      #                          # the wind update script
      # gridded and point output rate
      export DTFLD_WAV=`expr $FHOUT_HF_WAV \* 3600`
      export DTPNT_WAV=3600
      export FHINCP_WAV=`expr $DTPNT_WAV / 3600`
      
      # Grids for input fields
      export WAVEICE_DID=
      export WAVEICE_FID=
      export WAVECUR_DID=
      export WAVECUR_FID=
      export WAVEWND_DID=
      export WAVEWND_FID=
      
      # Selected output parameters (gridded)
      export OUTPARS_WAV=doc.output_settings.OUTPARS_WAV
      
      # Options for point output (switch on/off boundary point output)
      # export DOIBP_WAV='NO'
      #
      # # Intake currents settings
      export WAV_CUR_DT={doc.wave_settings.WAV_CUR_DT}
      export WAV_CUR_HF_DT={doc.wave_settings.WAV_CUR_HF_DT}
      export WAV_CUR_HF_FH={doc.wave_settings.WAV_CUR_HF_FH}
      export WAV_CUR_CDO_SMOOTH="{doc.wave_settings.WAV_CUR_CDO_SMOOTH}"
      
      # Number of cycles to look back for restart files
      export nback=
      
      if [ "$CDUMP" = "gdas" ]
      then
        WAVNCYC=4
        WAVHCYC=6
        FHMAX_WAV_CUR=48 # RTOFS forecasts only out to 8 days
      elif [ $gfs_cyc -ne 0 ]
      then
        FHMAX_WAV_CUR=192 # RTOFS forecasts only out to 8 days
        WAVHCYC=`expr 24 / $gfs_cyc`
      else
        WAVHCYC=0
        FHMAX_WAV_CUR=192 # RTOFS forecasts only out to 8 days
      fi
      export FHMAX_WAV_CUR WAVHCYC WAVNCYC
      
      export RSTTYPE_WAV='T' # generate second tier of restart files
      export DT_1_RST_WAV=10800 # time between restart files, set to DTRST=1 for a single restart file
      export DT_2_RST_WAV=43200  # restart stride for checkpointing restart
      export RSTIOFF_WAV=0 # first restart file offset relative to model start
      
      export RUNMEM={doc.wave_settings.RUNMEM}
      
      if [ $RUNMEM = -1 ]; then
      # No suffix added to model ID in case of deterministic run
      export waveMEMB=
      else
      # Extract member number only
      export waveMEMB=`echo $RUNMEM | grep -o '..$'`
      fi
      #
      # Determine if wave component needs input and/or is coupled
      export WW3ATMINP='CPL'
      export WW3ICEINP='CPL'
      export WW3CURINP='CPL'
      #
      if [ "$WW3ICEINP" = "YES" ]; then
      export WAVICEFILE=$CDUMP.t$((cyc))z.seaice.5min.grib2
      fi
      #
      # Determine if input is from perturbed ensemble (T) or single input file (F) for all members
      export WW3ATMIENS='F'
      export WW3ICEIENS='F'
      export WW3CURIENS='F'
      #
      
      # Set resources to propagate NTASKS across cfp call
      export NTASKS={doc.partition_common.resources.run_prep[0].mpi_ranks}
      #
      # # Path to HOME Directory
      export CODEwave="{doc.places.HOMEgfs}/sorc/fv3_coupled.fd/WW3"
      export EXECwave="{doc.places.HOMEgfs}/exec"
      export FIXwave="{doc.places.FIXwave}"
      export PARMwave="{doc.places.HOMEgfs}/parm/wave"
      export USHwave="{doc.places.HOMEgfs}/ush"
      export EXECcode="{doc.places.HOMEgfs}/sorc/fv3_coupled.fd/WW3/exec"
      #
      export MP_PULSE=0
      
      export wavelog=$COMOUTwave/wave.log
      
      # Set mpi serial command
      export wavempexec="{doc.wave_settings.wavempexec}"
      export wave_mpmd="{doc.wave_settings.wave_mpmd}"
      #
      # # Set wave model ID tag to include member number
      # # if ensemble; waveMEMB var empty in deterministic
      export WAV_MOD_TAG=$COMPONENTwave$waveMEMB
      #
      echo "END: config.wave"
