#------------------------------------------------------------------
# Denise.Worthen@noaa.gov (Feb 2019)
#
# This script will remap MOM6 ocean output on the tripole grid to 
# a set of rectilinear grids using pre-computed ESMF weights to remap 
# the listed fields to the destination grid and write the results 
# to a new netCDF file
#
# Prior to running this script, files containing the conservative 
# and bilinear regridding weights must be generated. These weights
# are created using the generate_iceocnpost_weights.ncl script.
#
# Note: the descriptive text below assumes fortran type indexing
# where the variables are indexed as (i,j) and indices start at 1
# NCL indices are (j,i) and start at 0
#
# The post involves these steps
#
#  a) unstaggering velocity points
#     MOM6 is on an Arakawa C grid. MOM6 refers to these 
#     locations as "Ct" for the centers and "Cu", "Cv" 
#     "Bu" for the left-right, north-south and corner 
#     points, respectively.
#
#     The indexing scheme in MOM6 is as follows:  
#
#        Cv@i,j
#     ----X------X Bu@i,j
#                |
#                |
#       Ct@i,j    |
#         X      X Cu@i,j
#                |
#                |
#                |
#
#     CICE5 is on an Arakawa B grid. CICE5 refers to these
#     locations as TLAT,TLON for the centers and ULAT,ULON
#     for the corners
#  
#     In UFS, the CICE5 grid has been created using the MOM6
#     supergrid file. Therefore, all grid points are consistent
#     between the two models. 
#   
#     In the following, MOM6's nomenclature will be followed,
#     so that CICE5's U-grid will be referred to as "Bu".
#
#  b) rotation of tripole vectors to East-West
#     MOM6 and CICE6 both output velocties on their native
#     velocity points. For MOM6, that is u-velocities on the
#     Cu grid and v-velocites on the Cv grid. For CICE5, it is
#     both u and v-velocities on the Bu grid.
#   
#     The rotation angle for both models are defined at center
#     grid points; therefore the velocities need to be first 
#     unstaggered before rotation. MOM6 and CICE5 also define 
#     opposite directions for the rotations. Finally, while the
#     grid points are identical between the two models, CICE5 
#     calculates the rotation angle at center grid points by 
#     averaging the four surrounding B grid points. MOM6 derives
#     the rotation angle at the center directly from the latitude
#     and longitude of the center grid points. The angles are therefor
#     not identical between the two grids.
# 
# c) conservative regridding of some fields
#    Fields such as ice concentration or fluxes which inherently
#    area area-weighted require conservative regridding. Most other
#    variables are state variables and can be regridded using
#    bilinear weighting.
#
# An efficient way to accomplish the unstaggering of velocities 
# is to use the bilinear interpolation weights between grid 
# points of the Arakawa C grid and the center grid points (for example 
# Cu->Ct). These weights are generated by the weight generation script 
#
# Remapping from the tripole to rectilinear uses either the bilinear
# or conservative weights from the weight generation script.  Bilinear weights 
# generated for the first vertical level can be used on other levels
# (where the masking changes) by utilizing the correct masking procedure.
# Set output_masks to true to examine the interpolation masks.
# 
# Intermediate file output can easily be generated for debugging by 
# follwing the example in the output_masks logical
#
# Bin.Li@noaa.gov (May 2019)
# The scripts is revised for use in the coupled workflow.
#
# Eric.Sinsky@noaa.gov (June 2023)
# The script has been ported from NCL to Python. 
#----------------------------------------------------------------------

from time import process_time
import os
import sys
import numpy as np
import netCDF4 as nc
import numpy.f2py
sys.path.append(os.getcwd()) #add working directory

def initfortranprog():
    fsource1 = '''
        subroutine bilin(src,S,row,col,frac_b,dst_len,dst,src_len,n_s)
           implicit none
           integer, intent(in) :: dst_len
           integer, intent(in) :: row(n_s)
           integer, intent(in) :: col(n_s)
           integer :: i,src_len, n_s
           real(kind=8), intent(in) :: frac_b(dst_len)
           real(kind=8), intent(in) :: src(src_len)
           real(kind=8), intent(in) :: S(n_s)
           real(kind=8), intent(out) :: dst(dst_len)

           !print*,"Starting bilinear interpolation"
           !print*,'n_s =',n_s
           !print*,'src_len =',src_len
           !print*,'dst_len =',dst_len

           ! Initialize destination field to 0.0
           do i=1,dst_len
             dst(i)=0.0
           enddo

           ! Apply weights
           do i=1, n_s
             dst(row(i))=dst(row(i))+S(i)*src(col(i))
           enddo
           
           do i=1, dst_len
             if (frac_b(i) .ne. 0.0) then
               dst(i)=dst(i)/frac_b(i)
             endif
           enddo

        end subroutine
    '''

    try:
        import esmfwghtinterp_f90subroutine
    except ImportError or ModuleNotFoundError:
        print('Weighted interpolation fortran subroutine has not been compiled. Compiling...')
        np.f2py.compile(fsource1, modulename='esmfwghtinterp_f90subroutine', verbose=False)
        import esmfwghtinterp_f90subroutine

def esmfmanualregrid(src,S,row,col,frac_b,n_s,varmeth,slatd,slond,dlatd,dlond):
    import esmfwghtinterp_f90subroutine 

    vardims=len(src.shape)
    if vardims == 4:
        nlevs=40
    if vardims == 3:
        nlevs=1

    dst=np.zeros(shape=(1,nlevs,dlatd,dlond),dtype=float)

    for i in range(0,nlevs): 

        if vardims == 4:
            src_oned=np.reshape(np.transpose(src[0,i,:,:]),(slatd*slond),'F')
        if vardims == 3:
            src_oned=np.reshape(np.transpose(src[0,:,:]),(slatd*slond),'F')

        if 1 == 0:
            dst_oned= np.zeros(shape=(dlatd*dlond),dtype=float)
            for m in range(0,n_s):
                dst_oned[row[m]-1]=dst_oned[row[m]-1]+S[m]*src_oned[col[m]-1]

        if 1 == 1:        
            dst_oned=esmfwghtinterp_f90subroutine.bilin(src_oned,S,row,col,frac_b,dlatd*dlond)

        dst[0,i,:,:] = np.transpose(np.reshape(dst_oned,(dlond,dlatd),'F'))
    return dst

def main():

    print('Main program has started')

    #Compile fortran subroutines if they have not already been compiled. 
    #If already compiled, load fortran-related modules into Python
    initfortranprog()

    if len(sys.argv) == 6:
        infiles0=sys.argv[1]
        outfiles0=sys.argv[2]
        nemsrc=sys.argv[3]
        parmfile=sys.argv[4]
        dstgrds=[sys.argv[5]]
    else:
        print('Incorrect number of arguments.')
        exit()

    if infiles0.endswith('.nc') and outfiles0.endswith('.nc'):
        print('Input and output files are netcdf.')
        infiles1=[sys.argv[1]]
        outfiles1=[sys.argv[2]]
        dimfiles=1
    else:
        with open(infiles0) as f1:
            infiles1 = f1.read().splitlines()
        with open(outfiles0) as f2:
            outfiles1 = f2.read().splitlines()

        dimfilesi=len(infiles1)
        dimfileso=len(outfiles1)

        if dimfilesi == dimfileso:
            dimfiles=dimfilesi
        else:
            print('ERROR: Input filelist must be same length as output filelist.')
            exit()

    output_masks=False
    methods=['bilinear','conserve']
    dsttype=['rect.']
    regridtype='manual' #manual or auto

    #If a parm file is given
    if len(sys.argv) == 6:
        print('Processing variables from parm')
        with open(parmfile) as f3:
            parmvars = f3.read().splitlines()

        nvarsall=len(parmvars)
        nvars=0
        nvpairs=0
        vartype=np.zeros(shape=(nvarsall),dtype=list)
        for nva in range(0,nvarsall):
            if ',' in parmvars[nva]:
                vartype[nva]='vector'
                nvpairs=nvpairs+1
            else:
                vartype[nva]='scalar'
                nvars=nvars+1

        parmvars_s=np.array(parmvars)[np.argwhere(vartype=='scalar')]
        parmvars_v=np.array(parmvars)[np.argwhere(vartype=='vector')]

        varlist=np.zeros(shape=(nvars,4),dtype=list)
        for nv in range(0,nvars):
            nvarparm1=np.char.split(parmvars_s[nv],':')
            varlist[nv,:]=nvarparm1[0]           

        veclist=np.zeros(shape=(nvpairs,4,2),dtype=list)
        for nv in range(0,nvpairs):
            nvectparm1=np.char.split(parmvars_v[nv],':')
            nvectparm2=nvectparm1[0]      
            for nvp in range(0,4):
                veclist[nv,nvp,:]=nvectparm2[nvp].split(',')

    #----------------------------------------------------------------------
    # make a list of the directories and files from the run 
    #----------------------------------------------------------------------

    #specify input file name and input directory
    print('Extracting Input Data')
    ocnf=nc.Dataset(infiles1[0])  #Read using nc
    

    #Get a list of available variables from netcdf file
    ncvarlist=ocnf.variables.keys()  #Get list of variables using nc

    #Check which model is to be post-processed 
    #by searching for a key variable specific to that model
    if 'SST' in ncvarlist:
        model='MOM'
    elif 'Tsfc_d' in ncvarlist or 'Tsfc_h' in ncvarlist:
        model='CICE'
        if 'Tsfc_d' in ncvarlist:
            samplevar='Tsfc_d'
        if 'Tsfc_h' in ncvarlist:
            samplevar='Tsfc_h' 
    else:
        print('Product not supported. Exiting program...')
        exit()
    print('Post-processing '+str(model))

    #Extract Source Grid coordinates
    if model == 'MOM':
        dimxh=ocnf.dimensions['xh'].size
        dimyh=ocnf.dimensions['yh'].size
    if model == 'CICE':
        dimxh=ocnf.dimensions['ni'].size
        dimyh=ocnf.dimensions['nj'].size

    print('Getting rotation angles and vertical grid')
    #get the rotation angles and vertical grid from the first file
    #two different name were used for the angles, either sinrot,cosrot 
    #or sin_rot,cos_rot
    if model == 'MOM':
        if 'sin_rot' in ncvarlist:
            sinrot=ocnf['sin_rot']
        else:
            sinrot=ocnf['sinrot']
        if 'cos_rot' in ncvarlist:
            cosrot=ocnf['cos_rot']
        else:
            cosrot=ocnf['cosrot']

        z_l=ocnf['z_l']
        z_i=ocnf['z_i']
        nlevs=len(z_l)

    if model == 'CICE':
        angleT=ocnf['ANGLET'] 

    #get a 2 and 3 dimensional fields for creating the interpolation masks
    #the mask2d,mask3d contain 1's on land and 0's at valid points.

    if model == 'MOM':
        ncfillval=ocnf['SST'][:].get_fill_value()
        SST=ocnf['SST'][:].filled(fill_value=np.nan)
        temp=ocnf['temp'][:].filled(fill_value=np.nan)
    if model == 'CICE':
        ncfillval=ocnf[samplevar][:].get_fill_value()
        SST=ocnf[samplevar][:].filled(fill_value=np.nan)

    if model == 'MOM':
        mask2d = np.where(np.isnan(SST),  1.0, 0.0)
        mask3d = np.where(np.isnan(temp),  1.0, 0.0)

        print('Conforming rotation arrays to 2d')
        #create conformed rotation arrays to make vector rotations cleaner
        sinrot2d=np.zeros(shape=(mask2d.shape),dtype=np.float64)
        cosrot2d=np.zeros(shape=(mask2d.shape),dtype=np.float64)
        sinrot2d[0,:,:]=sinrot[:]
        cosrot2d[0,:,:]=cosrot[:]

        print('Conforming rotation arrays to 3d')
        sinrot3d=np.zeros(shape=(mask3d.shape),dtype=np.float64)
        cosrot3d=np.zeros(shape=(mask3d.shape),dtype=np.float64)
        for i in range(0,nlevs):
            sinrot3d[0,i,:,:]=sinrot[:]
            cosrot3d[0,i,:,:]=cosrot[:]

    if model == 'CICE': 
        mask2d = np.where(np.isnan(SST),  1.0, 0.0)
        angleT2d=np.zeros(shape=(mask2d.shape),dtype=np.float64)
        angleT2d[0,:,:]=angleT[:]

    print('Checking which scalar variables are available in input file')
    #check for scalar variables in file. this is only required because
    #of the missing/misnamed MLD variables in the first BM
    #only the varlist is checked, since it is assumed there are
    #no other variables missing after the first benchmark
    valid=np.zeros(shape=(nvars),dtype=bool)
    valid[:]=False
    for nv in range(0,nvars):
        varname = varlist[nv,0]
        if varname in ncvarlist:
            valid[nv]=True
        print(varlist[nv,0]+'   '+str(valid[nv]))

    #check for vector variables in file. 
    #If at least one component of the vector is not in input file, 
    #then the entire vector pair will be ignorned
    validv=np.zeros(shape=(nvpairs),dtype=bool)
    validv[:]=False
    for nv in range(0,nvpairs):
        vecnames = veclist[nv,0,:]
        for nv2 in range(0,2):
            vecname=vecnames[nv2]
            if vecname in ncvarlist:
                validv[nv]=True
            else:
                validv[nv]=False
                break
        print(veclist[nv,0,0]+' and '+veclist[nv,0,1]+'  '+str(validv[nv]))

    #----------------------------------------------------------------------
    # loop over the output resolutions 
    #----------------------------------------------------------------------

    for jj in range(0,len(dstgrds)):

        outres = dstgrds[jj]+'x'+dstgrds[jj]
        outgrid = dstgrds[jj]

        if outgrid == '0p25':
            lond = np.arange(0, 360.0, 0.25)
            latd = np.arange(-90.0, 90.25, 0.25)
        if outgrid == '0p5':
            lond = np.arange(0, 360.0, 0.5)
            latd = np.arange(-90.0, 90.5, 0.5)
        if outgrid == '1p0':
            lond = np.arange(0, 360.0, 1.0)
            latd = np.arange(-90.0, 90.1, 1.0)

        wgtsfile1 = nemsrc+'/'+'tripole.mx025.Ct.to.'+dsttype[0]+dstgrds[jj]+'.bilinear.nc'        
        wgtsfile2 = nemsrc+'/'+'tripole.mx025.Ct.to.'+dsttype[0]+dstgrds[jj]+'.conserve.nc'
        if model == 'MOM':
            wgtsfile3 = nemsrc+'/'+'tripole.mx025.Cu.to.Ct.bilinear.nc'    
            wgtsfile4 = nemsrc+'/'+'tripole.mx025.Cv.to.Ct.bilinear.nc'
        if model == 'CICE':
            wgtsfile3 = nemsrc+'/'+'tripole.mx025.Bu.to.Ct.bilinear.nc'    
            wgtsfile4 = nemsrc+'/'+'tripole.mx025.Bu.to.Ct.bilinear.nc'

        print(wgtsfile1)
        print(wgtsfile2)
        print(wgtsfile3)
        print(wgtsfile4)

        #Extract regridding weights from netcdf files
        rgrdf1=nc.Dataset(wgtsfile1)
        S1=rgrdf1['S'][:].copy()
        row1=rgrdf1['row'][:]
        col1=rgrdf1['col'][:]
        frac_b1=rgrdf1['frac_b'][:]
        n_s1=len(S1)

        rgrdf2=nc.Dataset(wgtsfile2)
        S2=rgrdf2['S'][:].copy()
        row2=rgrdf2['row'][:]
        col2=rgrdf2['col'][:]
        frac_b2=rgrdf2['frac_b'][:]
        n_s2=len(S2)

        rgrdf3=nc.Dataset(wgtsfile3)
        S3=rgrdf3['S'][:].copy()
        row3=rgrdf3['row'][:]
        col3=rgrdf3['col'][:]
        frac_b3=rgrdf3['frac_b'][:]
        n_s3=len(S3)

        rgrdf4=nc.Dataset(wgtsfile4)
        S4=rgrdf4['S'][:].copy()
        row4=rgrdf4['row'][:]
        col4=rgrdf4['col'][:]
        frac_b4=rgrdf4['frac_b'][:]
        n_s4=len(S4)

        #Interpolate landmask to rectilinear grid 
        if model == 'MOM' or model == 'CICE':
            t1_start = process_time()
            print('beginning the regridding for mask2d') 
            if regridtype == 'manual':
                rgmask2d=esmfmanualregrid(mask2d,S1,row1,col1,frac_b1,n_s1,'bilinear',dimyh,dimxh,len(latd),len(lond))
            t1_stop = process_time()
            print("Remapped Elapsed time:", t1_stop-t1_start) 
            print('Data has been regridded for mask2d')
            rgmask2d = np.where(rgmask2d>0.0,  1.0, 0.0)

        if model == 'MOM':
            print('beginning the regridding for mask3d')                                                                                                                                                                                                 
            if regridtype == 'manual':
               rgmask3d=esmfmanualregrid(mask3d,S1,row1,col1,frac_b1,n_s1,'bilinear',dimyh,dimxh,len(latd),len(lond))
            print('Data has been regridded for mask3d') 
            rgmask3d = np.where(rgmask3d>0.0,  1.0, 0.0)       

        #Create Mask NETCDF File#########      
        testfile='masks_'+dstgrds[jj]+'.nc'
        os.system('rm -vf '+testfile)
        f = nc.Dataset(testfile,'w', format='NETCDF4') 

        if model == 'MOM':
            f.createDimension('z_l', nlevs) 
        f.createDimension('lon', len(lond))
        f.createDimension('lat', len(latd))
        f.createDimension('time', None)

        if model == 'MOM':
            depth = f.createVariable('z_l', 'f4', 'z_l')
            depth.long_name='Depth at cell center'
            depth.units = 'meters'

        longitude = f.createVariable('lon', 'f4', 'lon')
        longitude.long_name='longitude'
        longitude.units = 'degrees_east'

        latitude = f.createVariable('lat', 'f4', 'lat')  
        latitude.long_name = 'latitude'
        latitude.units = 'degrees_north'

        rgmask2dn = f.createVariable('rgmask2d1', 'f4', ('time', 'lat', 'lon'))
        if model == 'MOM':
            rgmask3dn = f.createVariable('rgmask3d', 'f4', ('time', 'z_l','lat', 'lon')) 
        time = f.createVariable('Time', 'i4', 'time')

        longitude[:] = lond    
        if model == 'MOM':                                                                                                                                                                                                                                                   
            depth[:]=z_l[:]
        latitude[:] = latd

        rgmask2dn[0,:,:] = rgmask2d
        if model == 'MOM':
            rgmask3dn[0,:,:,:] = rgmask3d

        f.close()

        #################################################

        for fl in range(0,dimfiles):
            t1_start = process_time()
            infile0=infiles1[fl]
            outfile0=outfiles1[fl]
            ocnf=nc.Dataset(infile0)
            print('Input file is '+infile0)
            print('Output file is '+outfile0)
        #Extract time
            intime=ocnf['time']
                
        #Create output regridded netcdf file 
            FILENAME_REGRID = outfile0
            os.system('rm -f '+FILENAME_REGRID)
            outcdf = nc.Dataset(FILENAME_REGRID,'w', format='NETCDF3_CLASSIC')
            outcdf.createDimension('time', None) 
            if model == 'MOM':                                                                                                                                                                                                                                                   
                outcdf.createDimension('z_l', nlevs) 
                outcdf.createDimension('z_i', nlevs+1) 
            outcdf.createDimension('lat', len(latd))
            outcdf.createDimension('lon', len(lond))

            time1 = outcdf.createVariable('time', 'f4', 'time')
            time1.units = intime.getncattr('units')
            time1.long_name=intime.getncattr('long_name')
            if model == 'MOM':                                                                                                                                                                                                                                                   
                time1.axis = intime.getncattr('axis')
                time1.calendar_type = intime.getncattr('calendar_type')
            time1.calendar = intime.getncattr('calendar')

            if model == 'MOM':                                                                                                                                                                                                                                                   
                depth1 = outcdf.createVariable('z_l', 'f4', 'z_l')
                depth1.long_name='Depth at cell center'
                depth1.units = 'meters'

                depth2 = outcdf.createVariable('z_i', 'f4', 'z_i')
                depth2.long_name='Depth at interface' 
                depth2.units = 'meters'

            longitude = outcdf.createVariable('lon', 'f4', 'lon')
            longitude.long_name='longitude'
            longitude.units = 'degrees_east'

            latitude = outcdf.createVariable('lat', 'f4', 'lat')  
            latitude.long_name = 'latitude'
            latitude.units = 'degrees_north'

            time1[:] = intime[:]
            latitude[:] = latd
            longitude[:] = lond
            if model == 'MOM':                                                                                                                                                                                                                                                   
                depth1[:]=z_l[:]
                depth2[:]=z_i[:]      
                 
    ###########################################################################
            for nv in range(0,nvars):
                if valid[nv] == True:
                    varname = varlist[nv,0]
                    vargrid = varlist[nv,1]
                    varmeth = varlist[nv,2]
                    vardims = varlist[nv,3]
                    print(varname+' '+vargrid+' '+varmeth+' '+vardims)

                    if varmeth == 'bilinear':
                        varregrid=esmfmanualregrid(ocnf[varname][:].filled(fill_value=0.0),S1,row1,col1,frac_b1,n_s1,varmeth,dimyh,dimxh,len(latd),len(lond))
                    if varmeth == 'conserve':
                        varregrid=esmfmanualregrid(ocnf[varname][:].filled(fill_value=0.0),S2,row2,col2,frac_b2,n_s2,varmeth,dimyh,dimxh,len(latd),len(lond))

                    if vardims == '2':
                        varregridf=np.where(rgmask2d==1,ncfillval,varregrid)
                        odims = np.array(['time', 'lat', 'lon'])
                    if vardims == '3':
                        varregridf=np.where(rgmask3d==1,ncfillval,varregrid)
                        odims = np.array(['time', 'z_l', 'lat', 'lon'])
                    if varname == 'MLD_003':
                        SSTrgn = outcdf.createVariable('mld', 'f4', odims,fill_value=ncfillval)
                        print('MLD_003 will be saved as mld in netcdf output')
                    else:
                        SSTrgn = outcdf.createVariable(varname, 'f4', odims,fill_value=ncfillval)
                    SSTrgn.units = ocnf[varname].getncattr('units')
                    SSTrgn.long_name = ocnf[varname].getncattr('long_name')
                    SSTrgn[:] = varregridf
                    del(vardims)
                    del(varregrid)
                    del(varregridf)

    ###########################################################################
            for nv in range(0,nvpairs):
                if validv[nv] == True:
                    vecnames = veclist[nv,0,:]
                    vecgrids = veclist[nv,1,:]
                    vecmeth  = veclist[nv,2,:]
                    vecdims  = veclist[nv,3,:]

                    print('Processing '+str(vecnames[0])+' and '+str(vecnames[1]))
                    #Unstagger U component
                    uvel=ocnf[vecnames[0]][:].filled(fill_value=np.nan)
                    vecfldu = np.where(np.isnan(uvel),0.0,uvel)
                    ut=esmfmanualregrid(vecfldu,S3,row3,col3,frac_b3,n_s3,'bilinear',dimyh,dimxh,dimyh,dimxh)

                    #Unstagger V component
                    vvel=ocnf[vecnames[1]][:].filled(fill_value=np.nan)
                    vecfldv = np.where(np.isnan(vvel),0.0,vvel)
                    vt=esmfmanualregrid(vecfldv,S4,row4,col4,frac_b3,n_s4,'bilinear',dimyh,dimxh,dimyh,dimxh)

                    #Rotate Vectors
                    if model == 'MOM':                                                                                                                                                                                                                                                   
                        if vecdims[0] == '2':
                            urot = ut[:,0,:,:]*cosrot2d[0,:,:]+vt[:,0,:,:]*sinrot2d[0,:,:]
                            vrot = vt[:,0,:,:]*cosrot2d[0,:,:]-ut[:,0,:,:]*sinrot2d[0,:,:]
                        if vecdims[0] == '3':
                            urot = ut[:,:,:,:]*cosrot3d[0,:,:,:]+vt[:,:,:,:]*sinrot3d[0,:,:,:]
                            vrot = vt[:,:,:,:]*cosrot3d[0,:,:,:]-ut[:,:,:,:]*sinrot3d[0,:,:,:]

                    if model == 'CICE':    
                        urot = np.cos(angleT2d[0,:,:])*ut[:,0,:,:] - np.sin(angleT2d[0,:,:])*vt[:,0,:,:]
                        vrot = np.sin(angleT2d[0,:,:])*ut[:,0,:,:] + np.cos(angleT2d[0,:,:])*vt[:,0,:,:]

                    uvrot = {}
                    uvrot['urot']=urot
                    uvrot['vrot']=vrot
                    uvrotname=list(uvrot.keys())

                    #Regrid urot
                    for v in range(0,2):         
                        if vecmeth[v] == 'bilinear':
                            rgttu=esmfmanualregrid(uvrot[uvrotname[v]],S1,row1,col1,frac_b1,n_s1,vecmeth[v],dimyh,dimxh,len(latd),len(lond))
                        if vecmeth[v] == 'conserve':
                            rgttu=esmfmanualregrid(uvrot[uvrotname[v]],S2,row2,col2,frac_b2,n_s2,vecmeth[v],dimyh,dimxh,len(latd),len(lond))
                        if vecdims[0] == '2':
                            rgttu = np.where(rgmask2d==1.0,ncfillval,rgttu)
                            odims = np.array(['time', 'lat', 'lon'])
                        if vecdims[0] == '3':
                            rgttu = np.where(rgmask3d==1.0,ncfillval,rgttu)
                            odims = np.array(['time','z_l', 'lat', 'lon'])
                        SSTrgn = outcdf.createVariable(vecnames[v], 'f4', odims,fill_value=ncfillval)
                        SSTrgn.units = ocnf[vecnames[v]].getncattr('units')
                        SSTrgn.long_name = ocnf[vecnames[v]].getncattr('long_name')  
                        SSTrgn[:] = rgttu

            t1_stop = process_time()
            print("Elapsed time:", t1_stop-t1_start) 
            print('Closing NETCDF output file')
            outcdf.close()

if __name__ == '__main__':
    main()

############################################################################
