# Set variables/lists needed to parse the enkf templates
{% set cycle_HH = current_cycle | strftime("%H") %}
{% set cycle_YMD = current_cycle | to_YMD %}
{% set cycle_YMDH = current_cycle | to_YMDH %}
{% set head = RUN + ".t" + cycle_HH + "z." %}

{% if IAUFHRS is string %}
{% set iaufhrs = [] %}
{% for iaufhr in IAUFHRS.split(",") %}
{% do iaufhrs.append(iaufhr | int) %}
{% endfor %}
{% else %}
{% set iaufhrs = [IAUFHRS] %}
{% endif %}

datasets:
{% if ENSGRP == 0 %}
{% filter indent(width=4) %}
{% include "enkf.yaml.j2" %}
{% endfilter %}
{% else %}

# Declare to-be-filled lists of member COM directories
{% set COM_ATMOS_ANALYSIS_MEM_list = [] %}
{% set COM_ATMOS_RESTART_MEM_list = [] %}
{% set COM_ATMOS_HISTORY_MEM_list = [] %}

{% set first_group_mem = (ENSGRP - 1) * NMEM_EARCGRP + 1 %}
{% set last_group_mem = [ ENSGRP * NMEM_EARCGRP, nmem_ens ] | min %}

# Construct member COM directories
{% for mem in range(first_group_mem, last_group_mem + 1) %}

# Declare a dict of search and replace terms to run on each template
{% set tmpl_dict = {'ROTDIR':ROTDIR,
                    'RUN':RUN,
                    'YMD':cycle_YMD,
                    'HH':cycle_HH,
                    'MEMDIR':"mem" + '%03d' % mem} %}

# Replace template variables with tmpl_dict, one key at a time
# This must be done in a namespace to overcome jinja scoping
#  Variables set inside of a for loop are lost at the end of the loop
#  unless they are part of a namespace
{% set com_ns = namespace(COM_ATMOS_ANALYSIS_MEM = COM_ATMOS_ANALYSIS_TMPL,
                          COM_ATMOS_HISTORY_MEM = COM_ATMOS_HISTORY_TMPL,
                          COM_ATMOS_RESTART_MEM = COM_ATMOS_RESTART_TMPL) %}

{% for key in tmpl_dict.keys() %}
{% set search_term = '${' + key + '}' %}
{% set replace_term = tmpl_dict[key] %}
{% set com_ns.COM_ATMOS_ANALYSIS_MEM = com_ns.COM_ATMOS_ANALYSIS_MEM.replace(search_term, replace_term) %}
{% set com_ns.COM_ATMOS_HISTORY_MEM = com_ns.COM_ATMOS_HISTORY_MEM.replace(search_term, replace_term) %}
{% set com_ns.COM_ATMOS_RESTART_MEM = com_ns.COM_ATMOS_RESTART_MEM.replace(search_term, replace_term) %}
{% endfor %}

{% do COM_ATMOS_ANALYSIS_MEM_list.append(com_ns.COM_ATMOS_ANALYSIS_MEM)%}
{% do COM_ATMOS_HISTORY_MEM_list.append(com_ns.COM_ATMOS_HISTORY_MEM)%}
{% do COM_ATMOS_RESTART_MEM_list.append(com_ns.COM_ATMOS_RESTART_MEM)%}

{% endfor %}

# Determine which members to archive
{% filter indent(width=4) %}
{% include "enkf_grp.yaml.j2" %}
{% endfilter %}

# Determine if restarts should be saved
{% set save_warm_start_forecast, save_warm_start_cycled = ( False, False ) %}

# Save the increments and restarts every ARCH_WARMICFREQ days
# The ensemble increments (group a) should be saved on the ARCH_CYC
{% if (current_cycle - SDATE).days % ARCH_WARMICFREQ == 0 %}
{% if ARCH_CYC == cycle_HH | int and current_cycle != SDATE %}
{% filter indent(width=4) %}
{% include "enkf_restarta_grp.yaml.j2" %}
{% endfilter %}
{% endif %}
{% endif %}

# The ensemble ICs (group b) are restarts and always lag increments by assim_freq
{% set ics_offset = (assim_freq | string + "H") | to_timedelta %}
{% if (current_cycle | add_to_datetime(ics_offset) - SDATE).days % ARCH_WARMICFREQ == 0 %}
{% if (ARCH_CYC - assim_freq) % 24 == cycle_HH | int and current_cycle != SDATE %}
{% filter indent(width=4) %}
{% include "enkf_restartb_grp.yaml.j2" %}
{% endfilter %}
{% endif %}
{% endif %}

{% endif %}  # ENSGRP != 0
